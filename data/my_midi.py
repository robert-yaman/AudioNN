import midi_inspect
import midi
import os 

class MyMidi(object):
    '''Abstract representation of a MIDI track. Lazily initializes different
    data representations as needed.
    '''

    def __init__(self, path=None, labels=None):
        ''' Can be initialized either with a path or with labels.
        Path is relative to AudioNN/data
        '''
        self._path = path
        self._labels = labels
        self._pattern = None
        self._note_pattern = None

    def labels(self):
        # Labels used as the output to the Neural Network
        if not self._labels:
            self._labels = midi_inspect.labelsForPath(self._path)
        return self._labels

    def pattern(self):
        # Pattern used by the midi library.
        if not self._pattern:
            if self._path:
                self._pattern = midi.read_midifile(self._path)
            elif self._labels:
                self._pattern = midi_inspect.midiFromLabels(self._labels)
        return self._pattern

    def note_pattern(self):
        # Representation of the MIDI used for audio conversion. Removes all
        # data except for notes and tempo (e.g. pedal).
        if not self._note_pattern:
            self._note_pattern = midi_inspect.noteTrackForPattern(self.pattern()[:])
        return self._note_pattern

    def audio(self):
        os.system("timidity %s" % self._path)

    def label_audio(self):
        # audio generated by re-interpretting the labels.
        tmp_path = "/tmp/tmp_mp3.mp3"
        new_midi = midi_inspect.midiFromLabels(self.labels())
        midi.write_midifile(tmp_path,new_midi)
        os.system("timidity %s" % tmp_path)
        os.system("rm %s" % tmp_path)



if __name__ == "__main__":
    path = "training_data/raw/k093.mid"
    m = MyMidi(path=path)
    m.note_pattern()
    m.pattern()
